{
  
    
        "post0": {
            "title": "Learning The Docker",
            "content": "What is Docker . Docker is a software platform that allows developer to build, test and deploy application quickly. In the nut shell, docker can deploy the developer application into different running environment. Let&#39;s say, someone with a &quot;Node&quot; with a different version can still run the application as the same as the developer have. . Docker compose of three main parts: . Docker files (Blue print of the Image. We need to modify this file to export our application) | Image (Environment, eg. Ubuntu, Node version, etc.) | Container (The package.json file, which contain all the library and the depandency.) | . Why use Docker . Docker enable the developer to develop at the local environment and ship easily. . How . First, download the Docker destop app here, which have both Mac and Window Version. Docker destop app contain a GUI, which can be more user-friendly for begineers. . Second, if using Visual Studio code, you can also install the docker extension, and run it internally with VS code terminal. . Common commands for Docker . terminal docker ps docker build docker run docker pull docker tag docker push . Writing an docker file . FROM used to specify Docker Image Name and start the build process . #specify a Base Image FROM ubuntu:latest FROM node:12 . Maintainer used to about the person who creates the Docker Image . MAINTAINER support@fosstechnix.com . CMD used to execute a command in Running container, There should be one CMD in a Dockerfile. . # To run apache2 in foreground CMD [&quot;/usr/sbin/apache2&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;] . RUN used to execute any commands on top of current Docker Image. . RUN executes the command when you are building Image. . FROM ubuntu:latest MAINTAINER support@fosstechnix.com RUN apt-get update RUN apt-get install -y apache2 . EXPOSE used to specify Network port for Docker container . # To Expose port 80 of Docker container EXPOSE 80 EXPOSE 8080/tcp . ENV used to set Environment Variables with key and value. . FROM node:12 ENV workdirectory /usr/node . VOLUME used to create or mount volume to docker container. . FROM node:12 RUN mkdir /node WORKDIR /node RUN echo &quot;Welcome to Node.js&quot; &gt; node VOLUME /node . Reference . Docker | AWS | Docker Cheat Sheet | Docker file Instructions | .",
            "url": "https://aungpaing98.github.io/blogs/software/docker/notes/2021/07/08/Docker.html",
            "relUrl": "/software/docker/notes/2021/07/08/Docker.html",
            "date": " • Jul 8, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Python Guide for Begineer",
            "content": "Data Types . In python, there are built-in data-types, some of which are described below: . Int (1 ,100, 99) | Float (1.0, 3.14, 2.718) | String (&quot;Myanmar&quot;, &quot;Burma&quot;) | Boolean (True, False) | Complex (1+0j) | null (None) | To describe the various properties in the real world, we must use different data types. . e.g., if we want to describe a person&#39;s name, we could use String. Int for his/her age, Float for his/her height in (cm) and Boolean if he/she is graduated or not. . The main take away from this lecture notebook is to know the differences between data types and their usage. . Four Most Used Data Types . We can store data of different types in variable names. See the example below: . # Int int1 = 5 int2 = 3 # Float float1 = 1. float2 = 3.14 # String string1 = &quot;Hello&quot; string2 = &#39;World&#39; # Boolean bool1 = True bool2 = False . print function is used to print the values of the variable to the output screen. . print(int1) . 5 . We can check the datatype of the variable by using type function: . type(int1) . int . Arithmetic Operations on Number Data Types . We could do arithmetic operations on Number Data Types (Int and Float) as shown below: . int1 = 5 int2 = 3 # We can add, subtract two elements of &#39;Int&#39; dtype. print(int1 + int2) # Addition print(int1 - int2) # Subtraction print(int1 * int2) # Multiplication print(int1 / int2) # Division print(int1 % int2) # Remainder print(int1**int2) # Power print(&quot;&quot;) float1 = 1. float2 = 3.14 # We can also, do operations on `Float` dtype. print(float1 + float2) print(float1 - float2) print(float1 * float2) print(float1 / float2) print(float1 % float2) print(float1**float2) . . 8 2 15 1.6666666666666667 2 125 4.140000000000001 -2.14 3.14 0.3184713375796178 1.0 1.0 . String Operations . We can use &#39;+&#39; operator to concatenate two strings. . # Simple concatenation of two strings concatenate_string = string1 + string2 print(concatenate_string) . HelloWorld . We can also use f-Strings method for better formating of string. . In f-Strings method, we can insert variables in the string format. . # f-Strings method. f_string = f&quot;Hello World, welcome to the wonderland&quot; print(f_string) string1 = &quot;Hello&quot; string2 = &quot;World&quot; f_string_var = f&quot;{string1} {string2}, This is testing the f-Strings&quot; print(f_string_var) . . Hello World, welcome to the wonderland Hello World, This is testing the f-Strings . . Important: One thing to be aware of in Python, we can not add two variables of different data types. In the example described below, we try to add Int and String data types, which is not possible. . var_a = &quot;Hello&quot; var_b = 5 print(var_a + var_b) . . TypeError Traceback (most recent call last) &lt;ipython-input-22-7f4a263b8c2b&gt; in &lt;module&gt; 2 var_b = 5 3 -&gt; 4 print(var_a + var_b) TypeError: can only concatenate str (not &#34;int&#34;) to str . # Or this print(int(var_a) + var_b) . . ValueError Traceback (most recent call last) &lt;ipython-input-23-c93ae652aa67&gt; in &lt;module&gt; 1 # Or this -&gt; 2 print(int(var_a) + var_b) ValueError: invalid literal for int() with base 10: &#39;Hello&#39; . When converting String to Int, if the value in that String is Int, then we can do addition. . # we could, for example var_a = &quot;5&quot; var_b = 5 print(int(var_a) + var_b) . . 10 . Boolean Operation . Boolean includes only two values, True and False. . Note: The capital letter and small letter must be correctly spelled.eg. true will not work. Boolean variables are often used in conditional operations, such as if and while. . bool1 = True bool2 = False # Check if a varible is True if bool1: print(&quot;bool1 variable is True&quot;) # This print statement is not working # because bool2 is not True if bool2: print(&quot;bool2 variable is True&quot;) . . bool1 variable is True . # Check if a variable is False (not True) if not bool1: print(&quot;bool1 variable is False&quot;) if not bool2: print(&quot;bool2 variable is False&quot;) . . bool2 variable is False . # We could use AND, OR operation too. if bool1 and bool2: print(&quot;Both Variables are True&quot;) if bool1 or bool2: print(&quot;At least one variable is True&quot;) . . At least one variable is True . Further Resources for Data Types . If you want to learn more about data types and their operations in more details, please visit to official Python documentation. You can also learn more about it in this blog post about Basic Data Types in Python. . Data Structures . Python Data Structures are used to store and collect data. There are four basic built-in data structures in Python. . # Simple Creation of each four types of structures list_obj = [1, 2, 3, 4, 1, 2, 3, 4] set_obj = {1, 2, 3, 4, 1, 2, 3, 4} tuple_obj = (1, 2, 3, 4, 1, 2, 3, 4) dict_obj = {&#39;a&#39;:1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:4, &#39;e&#39;:1, &#39;f&#39;:2} . print(type(list_obj), list_obj) print(type(set_obj), set_obj) print(type(tuple_obj), tuple_obj) print(type(dict_obj), dict_obj) . . &lt;class &#39;list&#39;&gt; [1, 2, 3, 4, 1, 2, 3, 4] &lt;class &#39;set&#39;&gt; {1, 2, 3, 4} &lt;class &#39;tuple&#39;&gt; (1, 2, 3, 4, 1, 2, 3, 4) &lt;class &#39;dict&#39;&gt; {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;e&#39;: 1, &#39;f&#39;: 2} . List . The Most commonly used data structure in Python, List, has the following properties : . Element are accessable with order | Mutable (variable values can be changed) | list_height = [170, 172, 174, 160, 178] print(&quot;Heights of student in class...&quot;) print(list_height) . Heights of student in class... [170, 172, 174, 160, 178] . Access with Index . . Note: If we access element that is out of range, it will rasie IndexError as follows . print(&quot;Student A height : &quot;, list_height[0]) print(&quot;Student B height : &quot;, list_height[1]) print(&quot;Student A height : &quot;, list_height[2]) print(&quot;Student B height : &quot;, list_height[3]) print(&quot;Student A height : &quot;, list_height[4]) print(&quot;Student B height : &quot;, list_height[5]) . . Student A height : 170 Student B height : 172 Student A height : 174 Student B height : 160 Student A height : 178 . IndexError Traceback (most recent call last) &lt;ipython-input-4-d5a3a372c0b9&gt; in &lt;module&gt; 4 print(&#34;Student B height : &#34;, list_height[3]) 5 print(&#34;Student A height : &#34;, list_height[4]) -&gt; 6 print(&#34;Student B height : &#34;, list_height[5]) IndexError: list index out of range . IndexError: list index out of range. Because there are only 5 elements in list, list_height[5] request for 6th element, which is out of range. . Access with Iteration(For Loop) . num_student = 0 for height in list_height: num_student += 1 print(height, end = &#39;,&#39;) print(f&quot; nThere are {num_student} students in the class&quot;) . . 170,172,174,160,178, There are 5 students in the class . &#39;&#39;&#39; Simple Program: Convert height information in &quot;cm&quot; to &quot;feet&quot; &#39;&#39;&#39; # Convert cm to feet for height_cm in list_height: height_feet = height_cm * 0.0328 # cm to feet equation print(f&quot;Studnet height : {height_cm} cm {height_feet:.2f} feet&quot;) . . Studnet height : 170 cm 5.58 feet Studnet height : 172 cm 5.64 feet Studnet height : 174 cm 5.71 feet Studnet height : 160 cm 5.25 feet Studnet height : 178 cm 5.84 feet . List with different Datatype . We can store, not just one datatype, but variables with different data types in a list. . student_A = [&quot;Aung Aung&quot;, &quot;McE&quot;, 3, 6] student_B = [&quot;Soe Pyae&quot;, &quot;Civil&quot;, 3, 6] print(&quot;Student A Info : &quot;, student_A) print(&quot;Student B Info : &quot;, student_B) . . Student A Info : [&#39;Aung Aung&#39;, &#39;McE&#39;, 3, 6] Student B Info : [&#39;Soe Pyae&#39;, &#39;Civil&#39;, 3, 6] . # But Be Aware, We do not know which element contain what information.. print(student_A[2] + student_A[3]) print(student_A[0] + student_A[1]) print(student_A[1] + student_A[2]) . . 9 Aung AungMcE . TypeError Traceback (most recent call last) &lt;ipython-input-5-b71be46f223e&gt; in &lt;module&gt; 2 print(student_A[2] + student_A[3]) 3 print(student_A[0] + student_A[1]) -&gt; 4 print(student_A[1] + student_A[2]) TypeError: can only concatenate str (not &#34;int&#34;) to str . TypeError :can only concatenate str to str | int to int This often happen in List when we try to store different data type into one list. It is hard to get exact index for each element. For that, in python, we use Dictionary to store key-value paired information. . Dictionary . When we walk into a library to find books, we search the book by its title, author or published year. Python use the same idea to store value for the varible, by creating the key for that value. Thus Dictionary in python is key-value paired data structure. . # List student_A_list = [&quot;Aung_Paing&quot;, &quot;McE&quot;, 3, 6] student_B_list = [&quot;Soe_Pyae&quot;, &quot;Civil&quot;, 3, 6] # Dictionary student_A_dict = {&quot;Name&quot; : &quot;Aung_Paing&quot;, &quot;Major&quot; : &quot;McE&quot;, &quot;Batch&quot; : 3, &quot;Year&quot; : 6} student_B_dict = {&quot;Name&quot; : &quot;Soe_Pyae&quot;, &quot;Major&quot; : &quot;Civil&quot;, &quot;Batch&quot; : 3, &quot;Year&quot; : 6} print(student_A_list) print(student_A_dict) . . [&#39;Aung_Paing&#39;, &#39;McE&#39;, 3, 6] {&#39;Name&#39;: &#39;Aung_Paing&#39;, &#39;Major&#39;: &#39;McE&#39;, &#39;Batch&#39;: 3, &#39;Year&#39;: 6} . # If we want to get &quot;Name&quot; info for student_A name_student_A = student_A[0] print(name_student_A) print() # But in dict, we just need to specified it. We do not need to remember the index of that info. print(&quot;Name : &quot;, student_A_dict[&quot;Name&quot;]) print(&quot;Major : &quot;, student_A_dict[&quot;Major&quot;]) print(&quot;Batch : &quot;, student_A_dict[&quot;Batch&quot;]) print(&quot;Year : &quot;, student_A_dict[&quot;Year&quot;]) . . Aung_Paing Name : Aung_Paing Major : McE Batch : 3 Year : 6 . Tuple . Sometimes, we need immutable data. For example, Coordinate of a location, your Birthday, your significant other&#39;s Phone Number or may be even your gene code. The data that we want to access but must be changed are stored with Tuple. . home_coordinate = (123, 456) birthday = (11, 1, 1998) print(type(birthday)) print(birthday) . . &lt;class &#39;tuple&#39;&gt; (11, 1, 1998) . # Let&#39;s try to access the month with index... month = birthday[1] print(month) # Let&#39;s try to change the day.... birthday[1] = 10 . . 1 . TypeError Traceback (most recent call last) &lt;ipython-input-11-c728f5c5b1e0&gt; in &lt;module&gt; 4 5 # Let&#39;s try to change the day.... -&gt; 6 birthday[1] = 10 TypeError: &#39;tuple&#39; object does not support item assignment . Thus, we can see the data in tuples cannot be changed . Set . Set as the name suggest, is a set of collection. Sets ignore the order and the number of elements in a collection and only store the representatives in that collection. . set_obj = {1, 2, 3, 1, 2, 3, 4} print(type(set_obj)) print(set_obj) . . &lt;class &#39;set&#39;&gt; {1, 2, 3, 4} . # We cannot access the elements in the set set_obj[0] . . TypeError Traceback (most recent call last) &lt;ipython-input-25-c6b65031723d&gt; in &lt;module&gt; 1 # We could not access the element in that set. -&gt; 2 set_obj[0] TypeError: &#39;set&#39; object is not subscriptable . Tips . Error When you encounter an Error in the code, try the following steps: . Stay calm &amp; Read the error message carefully | Copy and paste the error message in google search or stackoverflow. | Ask for help in forums if necessary. | There are more than 8 million python users in the world and it is very likely that someone has encounterd the same problem as you did. So, don&#39;t hesitate to search for help. . We can check the specification of the variable by: . set_obj? . Type: set String form: {1, 2, 3, 4} Length: 4 Docstring: set() -&gt; new empty set object set(iterable) -&gt; new set object Build an unordered collection of unique elements. . Further Resources for Data Structure . If you would like to know more about Data Structure in Python. Please visit official Python cocumentation. You can also learn more about it in this blog post about Common Python Data Structure . Conditionals &amp; Loops in Python . Conditionals . if Statements in Python allow us to tell the computer to perform alternative actions based on a certain set of results. . In other words, we are telling the computer : &quot;Hey if this case happens, perform some action&quot; . We can then expand the idea further with elif and else statements, which allows us to tell the computer: &quot;Hey if this case happens, perform some action. Else, if another case happens, perform some other action. Else, if none of the above cases happened, perform this action&quot; . Let&#39;s go ahead and look at the syntax format for if-else cases to get a better idea of this: . # Simple if-else case rain = False if not rain: print(&quot;The weather is fine today, I am going out.&quot;) else: print(&quot;It is raining, I cannot go out...&quot;) . . The weather is fine today, I am going out. . # Or this way: if rain==True: print(&quot;It is raining, I cannot go out...&quot;) else: print(&quot;Today weather is fine, I am going out.&quot;) . . Today weather is fine, I am going out. . # sometime, in the program, we have to deal with other conditions rain = False weekday = True if not rain and weekday: print(&quot;I am going to School Today&quot;) elif not rain and not weekday: print(&quot;I am going out to play&quot;) else: # Rain and weekday print(&quot;Even though it is raining, I still have to go to school ...&quot;) . . I am going to School Today . Also, we could check the String and Int variables: . Note: here, when checking if Condition == True, we use == instead of = . # Check String operation = &quot;add&quot; if operation == &quot;add&quot;: print(&quot;Add Operation&quot;) elif operation == &quot;sub&quot;: print(&quot;Sub Operation&quot;) elif operation == &quot;mul&quot;: print(&quot;Multiplication Operation&quot;) elif operation == &quot;div&quot;: print(&quot;Division Operation&quot;) . . Add Operation . # Check Int int_obj = 10 # int_obj = -1 # Comment out to test # int_obj = 0 # int_obj = None if int_obj: print(&quot;There exists value for that int_obj&quot;) else: print(&quot;sorry, the input is None or Zero&quot;) . . There exists value for that int_obj . Loops . There are two main types of loops in python. . for | while | Generally, For iterates for the given range, While checks the condition and continue iteration until condition is False. . for range(): . while condition: . For . A for loop acts as an iterator in Python; it goes through items that are in a sequence or any other iterable item. Objects, that we&#39;ve learned and we can iterate over, include strings, lists, tuples, and even built-in iterables for dictionaries, such as keys or values. . Here&#39;s the general format for a for loop in Python: . for item in object: statements to do things . # Loop for 10 times for i in range(10): print(i, end=&quot; &quot;) print() . . 0 1 2 3 4 5 6 7 8 9 . # Let&#39;s access element from list list_obj = [1, 2, 3, 4, 5, 6, 7, 8, 9] for obj in list_obj: print(obj, end=&quot; &quot;) . . 1 2 3 4 5 6 7 8 9 . Tuples have a special quality when it comes to for loops. If you are iterating through a sequence that contains tuples, the item can actually be the tuple itself, this is an example of tuple unpacking. During the for loop we will be unpacking the tuple inside of a sequence and we can access the individual items inside that tuple. . list1 = [(0,1),(2,3),(4,5)] for tup in list1: print(tup) . . (0, 1) (2, 3) (4, 5) . # Now with unpacking! for (t1,t2) in list1: print(t1, end=&quot; &quot;) . . 0 2 4 . In the above case, the first element of each tuple is printed out. . # Now with unpacking! for (t1,t2) in list1: print(t2, end=&quot; &quot;) . . 1 3 5 . Here, the second element of each tuple gets printed out. . With tuples in a sequence we can access the items inside of them through unpacking! The reason this is important is because many objects will deliver their iterables through tuples. . Nested For Loop . Nested For, means for loop inside a for loop . nested_list = [[1, 2, 3, 4], [5, 6, 7, 8]] # To access nested list, we could use nested for loop for row in nested_list: for col in row: print(col, end=&quot; &quot;) . . 1 2 3 4 5 6 7 8 . While . The while statement in Python is one of most general ways to perform iteration. A while statement will repeatedly execute a single statement or group of statements as long as the condition is true. The reason it is called a &#39;loop&#39; is because the code statements are looped through over and over again until the condition is no longer met. . The general format of a while loop is: . while condition: code statements else: final code statements . Let’s look at a few simple while loops in action. . # While loop and loop for 10 times. i = 0 while i&lt;10: print(i, end=&quot; &quot;) i+=1 . . 0 1 2 3 4 5 6 7 8 9 . x = 0 while x &lt; 5: print(&#39;x is currently:&#39;,x) print(&#39;x is still less than 5, keep adding 1 to x&#39;) x += 1 . . x is currently: 0 x is still less than 5, keep adding 1 to x x is currently: 1 x is still less than 5, keep adding 1 to x x is currently: 2 x is still less than 5, keep adding 1 to x x is currently: 3 x is still less than 5, keep adding 1 to x x is currently: 4 x is still less than 5, keep adding 1 to x . Notice how many times the print statements occurred and how the while loop kept going until the True condition was met, which occurred once x==5. It&#39;s important to note that once this occurred the code stopped. Let&#39;s see how we could add an else statement: . x = 0 while x &lt; 5: print(&#39;x is currently: &#39;,x) print(&#39;x is still less than 5, keep adding 1 to x&#39;) x += 1 else: print(&#39;All Done!&#39;) . . x is currently: 0 x is still less than 5, keep adding 1 to x x is currently: 1 x is still less than 5, keep adding 1 to x x is currently: 2 x is still less than 5, keep adding 1 to x x is currently: 3 x is still less than 5, keep adding 1 to x x is currently: 4 x is still less than 5, keep adding 1 to x All Done! . When the condition isn&#39;t true anymore, that is, x is now 5, and so the else statement All Done! is printed out instead. . Further Resources for Conditionals and Loops . If you want to learn more about conditional statements and loops in more details, please visit to official Python documentation. You can also learn more about conditional statements, for loops and while loops in these posts. . Functions . Functions are great arsenal in python. . You could think of functions as a factory, process (do function) the raw inputs (Arguments) to desired products (output). There are two types of functions in Python. . Built-in Functions | User-Defined Functions | Built-in Functions . We&#39;ve already seen a few example of built-in functions when learning about Data Types in Python. Built-in Functions, come along with python and could be very useful when you need them. . Following are some examples of built-in functions. . int_obj = -5 print(int_obj) # Find the absolute value abs_int = abs(int_obj) print(abs_int) # Convert Int to String int2str = str(int_obj) print(int2str, type(int2str)) # Check the datatype print(isinstance(int_obj, int)) . . -5 5 -5 &lt;class &#39;str&#39;&gt; True . We can also use built-in functions to construct data-structures. . set_obj = set((1, 2, 3, 1, 2, 3)) print(set_obj) list_obj = list((1, 2, 3, 1, 2, 3)) print(list_obj) tuple_obj = tuple((1, 2, 3, 1, 2, 3)) print(tuple_obj) dict_obj = dict([(1,&quot;a&quot;), (2, &quot;b&quot;)]) print(dict_obj) . . {1, 2, 3} [1, 2, 3, 1, 2, 3] (1, 2, 3, 1, 2, 3) {1: &#39;a&#39;, 2: &#39;b&#39;} . . User-Defined Functions . This section will consist of explaining what a function is in Python and how to create one. Functions will be one of our main building blocks when we construct larger and larger amounts of code to solve problems. . Typical function in python consists of the following parts: . Input (Arguments in functions) | Process (What this function do) | Output (What this function return) | In short, IPO for constructing a function. . Functions will be one of most basic levels of reusing code in Python, and it will also allow us to start thinking of program design (we will dive much deeper into the ideas of design when we learn about Object Oriented Programming). . def Statements . Let&#39;s see how to build out a function&#39;s syntax in Python. It has the following form: . def function_name(arg1,arg2): &#39;&#39;&#39; This is where the function&#39;s Document String (docstring) goes &#39;&#39;&#39; # Do stuff here # Return desired result . We begin with def then a space, followed by the name of the function. Try to keep names relevant though they can be variable, for example len() is a good name for a length() function. Also be careful with names, you wouldn&#39;t want to call a function the same name as a built-in functions(such as len). . Next comes a pair of parentheses with a number of arguments separated by a comma. These arguments are the inputs for your function. You&#39;ll be able to use these inputs in your function and reference them. After this you put a colon. . Now here is the important step, you must indent to begin the code inside your function correctly. Python makes use of whitespace to organize code. Lots of other programing languages do not do this, so keep that in mind. . Let&#39;s see the example of creating basic printing function. . # Define a function # No argument def print_hello(): print(&quot;Hello World&quot;) print_hello() # Call the funtion . . Hello World . Let&#39;s see some functions with input arguments. . # Argument with user name def print_hello(name): &quot;&quot;&quot; Print The User Name Args: name(String) -&gt; User name Return: None &quot;&quot;&quot; print(f&quot;Hello {name}! Welcome.&quot;) print_hello(&quot;Aung Aung&quot;) # Call the funtion . . Hello Aung Aung! Welcome. . # Arguments with different datatypes def print_hello(name, age): &quot;&quot;&quot; Print The User Name Args: name (String) -&gt; User name age (Int) -&gt; User Age Return: None &quot;&quot;&quot; print(f&quot;Hello {name}! Welcome. You are now {age} years old.&quot;) print_hello(&quot;Aung Aung&quot;, 22) # Call the funtion . . Hello Aung Aung! Welcome. You are now 22 years old. . Functions arguments can also have default values. See the example below. . # Argument having default value def print_hello(name, age = 18): &quot;&quot;&quot; Print The User Name Args: name (String) -&gt; User name age (Int) -&gt; User Age Return: None &quot;&quot;&quot; print(f&quot;Hello {name}! Welcome. You are now {age} years old.&quot;) # Because the &#39;age&#39; argument has default value, we don&#39;t need to provide value. print_hello(&quot;Aung Aung&quot;) print_hello(&quot;Aung Aung&quot;, 22) . . Hello Aung Aung! Welcome. You are now 18 years old. Hello Aung Aung! Welcome. You are now 22 years old. . Using return . Let&#39;s see some examples that use a return statement. return allows a function to return a result that can then be stored as a variable, or used in whatever manner a user wants. . def add_num(num1,num2,num3): return num1 + num2 + num3 . # Calling the function add_num(1,2,3) . . 6 . # Can also save as variable due to return result = add_num(1,2,3) print(result) . . 6 . # Let&#39;s try to make a power function def power(base_num, pow_num): &quot;&quot;&quot; Calculate the power of base_num Args: base_num(Int) -&gt; Base number for calculation pow_num(Int) -&gt; Power number for calculation Return: power_num(Int) -&gt; Power number for calculation &quot;&quot;&quot; return base_num ** pow_num # We can directly print out the value print(power(2, 3)) # Or we can assign the output value to a variable and print. output = power(3, 2) print(output) . . 8 9 . In the above function: We get the process of Calculate the Power of base_num, Input of base_num and pow_num. Output for power_num. . Further Resources for Functions . If you want to learn more about built-in functions in more details, please visit to official Python documentation. You can also check this blog post about Functions. . Classes . Classes are the main building blocks in Object Oriented Programming (OOP). OOP is one of the hardest parts for beginners when they are first starting to learn Python. But we will get you through OOP in the following section. So, let&#39;s start. . . Intro to OOP . Let&#39;s start the lesson by remembering about the Basic Python Objects. For example: . lst = [0, 1, 2, 3] . When we print out the type of that lst . print(type(lst)) . &lt;class &#39;list&#39;&gt; . This is the built-in Class of list. And we can call methods on that list with . lst.append(2) lst . [0, 1, 2, 3, 2] . Here, append is the method that the &lt;class &#39;list&#39;&gt; has. . Objects . Everything in Python is an object. We can use type() to check the type of object: . print(type(1)) print(type([])) print(type(())) print(type({})) . . &lt;class &#39;int&#39;&gt; &lt;class &#39;list&#39;&gt; &lt;class &#39;tuple&#39;&gt; &lt;class &#39;dict&#39;&gt; . So we know all these things are objects, so how can we create our own Object types? That is where the class keyword comes in. . Class and Attributes . class . User defined objects are created using the class keyword. The class is a blueprint that defines the nature of a future object. From classes we can construct instances. An instance is a specific object created from a particular class. For example: . t = (1, 2, 3) . We created the object t which was an instance of a tuple object. . Now, Let&#39;s try a step up and create our own class. . # Construct a new object type called Student class Student: pass # Instance of the class Student x = Student() print(type(x)) . &lt;class &#39;__main__.Student&#39;&gt; . Most of the programmers give classes a name that starts with a capital letter by convention. Note how x is now the instance of a Student class. In other words, we instantiate the Student class. . At the inside of the class we currently just have pass keyword. But we can define class attributes and methods. . An attribute is a characteristic of an object.A method is an operation we can perform with the object. . For example, we can create a class called Dog. An attribute of a dog may be its breed or its name, while a method of a dog may be defined by a .bark() method which returns a sound. . Attributes . The syntax for creating an attribute is: . self.attribute = something . There is a special method called: . __init__() . This method is used to initialize the attributes of an object. For example: . class Student: def __init__(self, name): self.name = name a = Student(name = &#39;Aung Paing&#39;) b = Student(name = &#39;Soe Pyae Phyo&#39;) . Let&#39;s break down what we have above. The special method . __init__() . is called automatically right after the object has been created. . def __init__(self, name): . Each attribute in a class definition begins with a reference to the instance object. It is by convention named self. The name is the argument. The value is passed during the class instantiation. . self.name = name . . Note: self.name can be given any desire variable names; no need to be name. For example, self.student_name = name Now we have created two instances of the Student class. With two different names, we can then use these attributes like this: . a.name . &#39;Aung Aung&#39; . b.name . &#39;Soe Soe&#39; . Note how we don&#39;t have any parentheses after name; this is because it is an attribute and doesn&#39;t take any arguments. . Lets add more attributes to our Student class. . class Student: def __init__(self, name, major, batch, age, passedlastterm): self.name = name self.major = major self.batch = batch self.age = age self.passedlastterm = passedlastterm student_a = Student(&quot;Myo Myo&quot;, &quot;EC&quot;, 3, 24, True) student_b = Student(&quot;Su Su&quot;, &quot;Text&quot;, 2, 18, False) print(&quot; nStudent a Data :&quot;) print(student_a.name) print(student_a.major) print(student_a.batch) print(student_a.age) print(student_a.passedlastterm) . . Student a Data : Myo Myo EC 3 24 True . Methods . Methods are functions defined inside the body of a class. They are used to perform operations with the attributes of our objects. Methods are a key concept of the OOP pattern. They are essential to dividing responsibilities in programming, especially in large applications. . Let&#39;s go through an example of creating a Square class: . class Square: # Square gets instantiated def __init__(self, length = 4): self.length = length self.area = length * length # Resetting length def setLength(self, new_length): self.length = new_length self.area = new_length * new_length s = Square() print(&#39;Length is &#39;, s.length) print(&#39;Area is &#39;, s.area) s.setLength(6) print(&#39;Now length is &#39;, s.length) print(&#39;Now area is &#39;, s.area) . . Length is 4 Area is 16 Now length is 6 Now area is 36 . In this Square class, we have defined two attributes: self.length and self.area. . def setLength(self, new_length): . is called method of the class, which we use to interact with the user and manipulate the class attributes. Notice how we used self. notation to reference attributes of the class within the method calls. . Now, Let&#39;s add some methods to Student class. . class Student: def __init__(self, name, major, batch, age, passedlastterm): self.name = name self.major = major self.batch = batch self.age = age self.passedlastterm = passedlastterm def print_result(self): if self.passedlastterm: print(&quot;Congrats, you can move to next term.&quot;) else: print(&quot;Sorry, you need to retake the exam.&quot;) student_a = Student(&quot;Myo Myo&quot;, &quot;EC&quot;, 3, 24, True) print(&quot;Student a Result&quot;) student_a.print_result() . . Student a Result Congrats, you can move to next term. . Inheritance . Inheritance is a way to form new classes using classes that have already been defined. The newly formed classes are called derived classes, the classes that we derive from are called base classes. Important benefits of inheritance are code reuse and reduction of complexity of a program. The derived classes override or extend the functionality of base classes. . Let&#39;s use our Student class again. . # Inheritance and not change anything. class ExchangeStudent(Student): pass . In this example, we have two classes: Student and ExchangeStudent. The Student is the base class, the ExchangeStudent is the derived class. . The derived class inherits the functionality of the base class. This is shown in the example below. . # ExchangeStudent should have all properties and methods Student has. student_ex = ExchangeStudent(&quot;Htet Htet&quot;, &quot;Civil&quot;, 1, 25, True) print(&quot; nStudent ex Result&quot;) student_ex.print_result() . Student ex Result Congrats, you can move to next term. . Further Resources for Class . If you want to learn more about Object Oriented Programming (OOP) in more details, please visit to official Python documentation. You can also check this blog post about OOP. . Icons made by Freepik from www.flaticon.com",
            "url": "https://aungpaing98.github.io/blogs/python/2020/12/14/python.html",
            "relUrl": "/python/2020/12/14/python.html",
            "date": " • Dec 14, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Basic Image Processing with Python",
            "content": "Image Acquisition . Images, taken from real life with camera, and then stored as the digital format in computer. In digital format, the images are represented by three color channel. (Red, Green and Blue). . In Python, we can read in the image with matplotlib library in following way : . img = matplotlib.image.imread(img_name) . After reading the image with above method, the variable img will contain the image value as the array in ndarray data type. We can also inspect the dimension(channel) of image in code with: . h, w, d = img.shape . 16, 16, 3 . As the above fig show, the mario image have 16 by 16 pixel values. So, h and w will be 16 x 16 and color image have 3 dimension. . Arithemetic Operations . Since Images are actually numbers, we could use functions to operate on the images. The most basic function would be adding, subtracting, multiplication and division. We will introduce Adding and Subtracting here in this blog post. . import matplotlib.image as mpimg import matplotlib.pyplot as plt import numpy as np import cv2 . # Helper Function for showing Images def imShow(imgs, titles=None): num = len(imgs) x = (num//4)+1 y = int(np.ceil(num/x)) plt.figure(figsize=(18,15)) for i in range(num): plt.subplot(x, y, i+1) cmap=None title=None if imgs[i].ndim==2:cmap=&#39;gray&#39; if titles!=None:title=titles[i] plt.imshow(imgs[i], cmap=cmap) plt.title(title,fontdict={&#39;fontsize&#39;:23}) plt.tight_layout() plt.show() . . Subtract Two Images . In the below Image, the subtracted result shows the difference between two images. . Note: While subtracting, we need to be careful of the data type range. Image arrays are typically in the range of 0 ~ 255. The data type is np.uint8. If it is negative value, it will subtract that negative value with 256. . Below show the example: . &#39;&#39;&#39;Because &#39;b&#39; is in the range of 0 ~ 255, while it exceed that value, it will subtract from 256. eg. here, &#39;b&#39; should be -5, so, it would be &#39;256-5 = 251&#39; &#39;&#39;&#39; a = np.array([5]) b = (a-10).astype(np.uint8) print(b) . . [251] . img1 = mpimg.imread(&#39;1.jpg&#39;) img2 = mpimg.imread(&#39;2.jpg&#39;) # First let&#39;s check their dimension assert img1.shape == img2.shape # Extend range so there won&#39;t be gibberish # diff = img2 - img1 diff = img2.astype(np.int16) - img1.astype(np.int16) diff[diff&lt;0] = 0 imShow([img1, img2, diff], [&#39;img1&#39;, &#39;img2&#39;, &#39;Difference&#39;]) . . Add Two Images . We can also add two images if they are in the same Dimension. . img1 = mpimg.imread(&#39;bird.jpg&#39;) img2 = mpimg.imread(&#39;back.jpg&#39;) h, w, d = img2.shape print(f&#39;Before resize : &#39;, img1.shape, img2.shape) img1 = cv2.resize(img1, (w, h)) print(f&#39;After resize : &#39;, img1.shape, img2.shape) add = img2.astype(np.int16) + img1.astype(np.int16) add[add&gt;255] = 255 imShow([img1, img2, add]) . . Before resize : (478, 717, 3) (421, 748, 3) After resize : (421, 748, 3) (421, 748, 3) . . Important: Both Adding and Subtracting two images need to have both same dimension for both inputs. . Geometric Transformations . Rotation, Crop . Rotation in the image is achieved by applying the transformation matrix to the image. | . M = cv2.getRotationMatrix2D((center_x, center_y), angle_to_rotate, scale) rotated = cv2.warpAffine(img, M, (x, y)) . Cropping is just simply Slicing of the image(numpy array). | . cropped = img[x_coor:x_coor, y_coor:y_coor] . # Rotation img = mpimg.imread(&#39;tower.jpg&#39;) h, w, d = img.shape simple = cv2.rotate(img, cv2.cv2.ROTATE_90_CLOCKWISE) # More Flexible This Way M = cv2.getRotationMatrix2D((w/2, h/2), 90, 1) rotated = cv2.warpAffine(img, M, (h+100, w)) M = cv2.getRotationMatrix2D((w//2, h//2), 45, 0.5) rotated_ = cv2.warpAffine(img, M, (w, h)) imShow([img, simple, rotated, rotated_], [&#39;Tower&#39;, &#39;Simple Rotate&#39;, &#39;90 degree Rotated&#39;, &#39;45 degree Rotated&#39;]) . . # Crop [Image Slicing] img_copy = np.copy(img) door = img_copy[420:, 150:250, :] bicycle = img_copy[500:, 270:, :] imShow([img, door, bicycle], [&#39;Original Image&#39;, &#39;Door&#39;, &#39;Bicycle&#39;]) . . Color Image Transformation . RGB -&gt; BGR -&gt; HSV . Image can be converted to various color space by cv2.cvtColor(src, cv2.COLOR_). . Typically, if the image is read with matplotlib.image.imread(file_name), then it would read in with RGB format. And matplotlib.pyplot.imshow(img_array) would read the array as RGB format and display it. . While cv2.imread(file_name) would read in with BGR format and cv2.imshow() display as it take the array in BGR format. . Warning: read with matplotlib and plot with cv2 will result in Color space shift. . img = mpimg.imread(&#39;parrot.jpg&#39;) bgr = cv2.cvtColor(img, cv2.COLOR_RGB2BGR) imShow([img, bgr], [&#39;Original Image&#39;, &#39;BGR Image&#39;]) . . Unlike other color space, in HSV, the range for hue is from 0 ~ 179. . Hue value actually represent what we human understand of color. . eg. For red color, hue value would always be 0, regardless of the change in brightness and saturation. . img = mpimg.imread(&#39;parrot.jpg&#39;) hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV) h = hsv[:, :, 0];s = hsv[:, :, 1];v = hsv[:, :, 2] print(&#39;hue t t&#39;, np.min(h), np.max(h), &#39; nsaturation t&#39;, np.min(s), np.max(s), &#39; nvalue t t&#39;, np.min(v), np.max(v)) imShow([h, s, v], [&#39;Hue&#39;, &#39;Saturation&#39;, &#39;Value&#39;]) . . hue 0 179 saturation 0 255 value 0 255 . Resizing Image . For the resizing, there are two cases: . Downsampling (Resized Image have lesser resolution than original One) | Upsampling (Resized Image have more resolution than original One) | . Also, there are many Interpolation methods to achieve resizing: . INTER_NEAREST (nearest-neighbour interpolation) | INTER_LINEAR (bilinear interpolation) | INTER_AREA (pixel area relation interpolation) [preferred for downsampling] | INTER_CUBIC (bicubic interpolation) | INTER_LANCZOS4 (lanczos interpolation) | . | . resized = cv2.resize(img, resized_dimension, interpolations=methods) . # Resizing img = mpimg.imread(&#39;lenna.png&#39;) h, w, d = img.shape dims = (w//2, h//2) dims_ = (w*2, h*2) downscale = cv2.resize(img, dims, interpolation=cv2.INTER_AREA) upscale = cv2.resize(img, dims_, interpolation=cv2.INTER_CUBIC) upscale_ = cv2.resize(img, dims_, interpolation=cv2.INTER_AREA) img = img[100:160, 100:160] downscale = downscale[50:80, 50:80] upscale = upscale[200:320, 200:320] upscale_ = upscale_[200:320, 200:320] imShow([img, downscale, upscale, upscale_], [f&#39;Original Image : {img.shape}&#39;, f&#39;Downscale Image : {downscale.shape}&#39;, f&#39;Upscale_cubic&#39;, f&#39;Upscale_area&#39;]) . . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . Image Enhancing . Sometime, we get the image that is too dark or too bright, that it lose the information for the image. . For that, we could use transform in gray scale to hightlight the place in the image that we interest in. . The basic methods for that would be : . Negative | Log Transform | Gamma Transform | Contrast Stretching (Normalization) | Histogram Equalization | Here, we will focus on the first three method. . Note: Here, We show with just gray scale, But you can always try with all 3 Color spaces and stack them later with np.dstack((r, g, b)) if it is the color image. . Negative . Effect : Bright region turn to dark and dark region turn to bright.(invert of image). . Equation : $$y = 255-x$$ . Log Transform . Effect : Add brightness to where the image is dark. . Equation : $$y = log(c+x)$$ where : $c$ = constance, $x$ = Normalized pixel . Code : . # Normalized Image x = x/255 y = np.log(c + x) . Gamma Transform . Effect : Adjustable change in brightness with gamma value. . Equation : $$y = x**r$$ where : $r$ = gamma . Code : . # Normalized Image x = x/255 y = x**r . img_names = [&#39;bird.jpg&#39;, &#39;F3.jpg&#39;, &#39;PCL.jpg&#39;, &#39;cells.jpg&#39;, &#39;tree.jpg&#39;] for img_name in img_names: img = mpimg.imread(img_name) if img.ndim&gt;=3: img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) negative = 255-img img_copy = np.copy(img).astype(np.float32) img_copy /= 255 log = np.log(1.0+img_copy) # imShow([img, negative, log], [&#39;Orignal Image&#39;, &#39;Negative Image&#39;, &#39;Log Image&#39;]) imShow([img, negative, log], [&#39;Orignal Image&#39;, &#39;Negative&#39;, &#39;Log Image&#39;]) . . And Gamma correction with difference gamma value : . gamma0 = 0.5 gamma1 = 1 gamma2 = 1.5 img = mpimg.imread(&#39;tree.jpg&#39;) if img.ndim&gt;=3: img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) r0 = 1/gamma0 result0 = (img/255)**r0 r1 = 1/gamma1 result1 = (img/255)**r1 r2 = 1/gamma2 result2 = (img/255)**r2 imShow([img, result0, result1, result2], [&#39;original image&#39;, f&#39;gamma value : {gamma0}&#39;, f&#39;gamma value : {gamma1}&#39;, f&#39;gamma value : {gamma2}&#39;]) . . As Gamma value increase, the image get brighter. . Image Gradient . Edge Detection . Edge detection is the process of finding the boundaries (shape) of objects in the image. It works by detecting the change in pixel value in the image. . There are many ways to find the edge in the image. Mainly difference in the filter. Here, we will introduce two mostly used filter. . Sobel Filter (L1)sobel = cv2.Sobel(img, filter_size, dx, dy) . | Laplacian Filter (L2)laplace = cv2.Laplacian(img, cv2.CV_64F, ksize) . | After finding the edge, we could also use that to sharpen(enhance the edge) the image. So, we could Smooth (Blur) the image and sharp the image. . Smoothing (Blurring) Image . Commanly used method: . Gaussian Filterblurred = cv2.GaussianBlur(img, filter_size(tuple), std) . | Median Filter (Used to filter salt noise) . blurred = cv2.medianBlur(img, filter_size(int)) . Belowing show the Difference in Edge detection Method. . | def sobelEdge(img): sobelx = np.abs(cv2.Sobel(img, 3, 0, 1)).astype(np.uint32) sobely = np.abs(cv2.Sobel(img, 3,1, 0)).astype(np.uint32) sobel = np.sqrt(np.square(sobelx) + np.square(sobely)) sobel = (sobel/np.max(sobel)) * 255 return sobel.astype(np.uint8) def laplaceEdge(img): laplace = np.abs(cv2.Laplacian(img, cv2.CV_64F, ksize=3)) laplace = ((laplace/np.max(laplace)) * 255).astype(np.uint8) return laplace img_names = [&#39;dark.jpg&#39;, &#39;page.jpg&#39;,&#39;tower.jpg&#39;] for img_name in img_names: img = mpimg.imread(img_name) gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) sobel = sobelEdge(gray) laplace = laplaceEdge(gray) imShow([gray, sobel, laplace], [f&#39;Original image{img.shape}&#39;, f&#39;Sobel{sobel.shape}&#39;, f&#39;Laplacian{laplace.shape}&#39;]) . . And the result of Smoothing and Sharpening of images. . def smooth(img): blurred = cv2.GaussianBlur(img, (9,9), 1) return blurred def sharp(img): blurred = cv2.GaussianBlur(img, (5, 5), 1).astype(np.float32) img = img.astype(np.float32) result = np.abs((1.5*img) - (0.5*blurred)) result = ((result/np.max(result)) * 255).astype(np.uint8) return result blurred = smooth(gray) sharped = sharp(gray) door = gray[420:, 150:250] door_blurred = blurred[420:, 150:250] door_sharped = sharped[420:, 150:250] imShow([gray, blurred, sharped, door, door_blurred, door_sharped], [&#39;Original Image&#39;, &#39;Smoothed Image&#39;, &#39;Sharped Image&#39;, &quot;Original Door&quot;, &#39;Blurred Door&#39;, &#39;Sharped Door&#39;]) . . Image Segmentation . The image show in plt.imshow() typically take three types of range. . uint8, range from (0~255)[total of 256 level] | float64, range from (0~1)[total of many floating level]&lt;eg. 0.1, 0.11, 0.111&gt; | Binary Image, contain only (0 and 1)[2 level]&lt;0 mean dark and 1 mean light&gt; | . Usually, we use binary image in Mask. . 1 mean object and 0 mean background. . # Gray Scale Image img1 = np.array([[0, 50, 100, 150, 200, 255], [0, 50, 100, 150, 200, 255], [0, 50, 100, 150, 200, 255], [0, 50, 100, 150, 200, 255]]) # Binary Image img2 = np.array([[0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1]]) imShow([img1, img2], [&#39;Gray scale Image&#39;, &#39;Binary Image&#39;]) . . For the thresholding, two methods can be used. . Global Thresholding (one threshold value for all region in the image) | Typically, we set the threshold value to random number, or we find the best threshold value by trial and error. Or we can use **otsu** method, which find the optimized threshold value from intensity histogram of image. . Adaptive Thresholding | Since the lighting condition in different region in a single image can be different, Adaptive thresholding method is often better than global method. . Adaptive threshold use difference threshold value in different region. . # Global Threshold img = mpimg.imread(&#39;page.jpg&#39;) gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) # 0 ~ 255 gray = cv2.medianBlur(gray, 5) glob_thresh = np.ones_like(gray) glob_thresh[gray&lt;25] = 0 # 0 &amp; 1 adap_thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, 3) _, otsu_thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU) imShow([gray, glob_thresh, otsu_thresh, adap_thresh], [&#39;gray&#39;, &#39;global_threshold&#39;, &#39;otsu_Threshold&#39;, &#39;Adaptive_threshold&#39;]) . . Since thresholding process is transforming gray scale image to Binary one, it is also called binarization. . Different method for thresholding would be useful in different scenerios.The best way to find the best method is by trial and error. . For example, althought gobal thresholding method may not give better result than adaptive one, but its speed is faster casue there is not need to find the threshold value, by assigned by the user. . Morphological Transformations . Morphological transform is the transformation of shape in the binarization image. Typically used to modify the Mask (Binary Image). . Mostly Used methods are called: . Erosion (Reduce Shape) | Dilation (Expand Shape) | And the combination of these methods evolved to: . Opening (Disconnect closely related part) | Closing (Connect closely related Part) | img = mpimg.imread(&#39;cells.jpg&#39;) gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) gray = cv2.medianBlur(gray, 5) gray = gray[30:, :] # Let&#39;s do some thresholding thresh = np.zeros_like(gray) # threshold value here get by trial and error thresh[gray&gt;175] = 1 kernel = np.ones((5,5), np.uint8) #Erosion eroded = cv2.erode(thresh, kernel, iterations=1) #Dilation dilated = cv2.dilate(thresh, kernel, iterations=1) # Opening (Erosion + Dilation) opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel) # Closing (Dilation + Erosion) closing = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel) imShow([gray, thresh, eroded, dilated, opening, closing], [&#39;Gray Scale Image&#39;, &#39;Binary Threshold Image&#39;, &#39;Eroded Image&#39;, &#39;Dilated Image&#39;, &#39;Morpho Open&#39;, &#39;Morpho Close&#39;]) . . In Opening, the method open(separate) the closely connected part. Opening is achieved by first erosion, then dilation. . In Closing, the method close(connect) the closely connected part. Closing is achieved by first dilation, then erosion. . thresh_ = thresh[100:200, 150:250] open_ = opening[100:200, 150:250] close_ = closing[100:200, 150:250] imShow([thresh_, open_, close_], [&#39;Original Binary&#39;, &#39;Opeing&#39;, &#39;Closing&#39;]) . . Conclusion . The Above mentioned methods are all just basic image processing techniques. There are certainly many more state of the art algorithms. . But, If we get the idea that image are numbers and various functions could be apply to the image, then, we could modify and create intereting projects in computer vision. .",
            "url": "https://aungpaing98.github.io/blogs/image_processing/overview/2020/11/22/image_processing_overview.html",
            "relUrl": "/image_processing/overview/2020/11/22/image_processing_overview.html",
            "date": " • Nov 22, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "CS50 Study Note",
            "content": "Notes . This notebook is referenced from the CS50 course conducted by MIT lectures online from youtube. The course can be found in this youtube link. . Previews . My programming jorney starts from 3 years ago, when I first learn Python from youtube. It is a easy programming compare to others. Before that, I have attended lectures from university for basic comptuer science in C++ language. It was not a very productive one. And after I learnt Python, it is superficial, I now know that, to get the best performance of the algorithms, I need to know the logic behind all the pre-built function. That is why I started learning this course. . CS50, this lecture is really one of the top in my favorate list from my learning jorney. The lectures is energetic, explaning the lowest detail of the programming. I wish I have seen this lecture sooner. . Lectures 1 - C . The lecture is mainly conducted with using C langauge in first 5 lectures of the course. C language is the low level language meaning we can get the best performance in speed compare to other languages if the algorithms is optimized. . Good coding practice . To get the most efficient code, meaning it is functionable, able to get the desired output, it have a good design, most efficient and it have a good style, so everyone can understand the code. . $$ Code begin{cases} quad text{Functionable} quad text{Design} quad text{Style} end{cases} $$Command Line Interface (CLI) and Graphic User Interface (GUI) . Developer often use command line (terminal in mac) to execute the program. CLI is less user friendly than GUI, it needs a bit more knowledge but it is hackable and origin. The terminal is a platform which we can use complier to compile the code to machine code and open that machine code to get the output of the program. . So, the typical process is, . Write the code with text editor (visual studio code, atom, etc) | Compile the code in terminal with compiler and output machine code. | Run the machine code and output the result in terminal. | . Compiler is the program that is pre-written to convert the code that we write to machine code, that the computer understand. Different language have different compiler. And in mac, we need to install X-Code to run C program cause X-code is the compiler that contain multiple languages including C. .",
            "url": "https://aungpaing98.github.io/blogs/computer_science/basic/algorithms/2020/02/22/CS50.html",
            "relUrl": "/computer_science/basic/algorithms/2020/02/22/CS50.html",
            "date": " • Feb 22, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Notes from Advanced Numpy (Scipy Japan 2019)",
            "content": "Abstrast . &quot;Scipy Japan 2019&quot;is the 18th annual Scientific Computing with Python conference. This note is taken from the &quot;Advanced Numpy&quot; topic, speech by Juan Nunez-Iglesias. The source code for speech is available at github. . I came across this on youtube. The speech give some aspect of Numpy that I am getting confused before, so, this notebook helps me to get more hand on Numpy. Let&#39;s get started. . A Little Introduction to DNA and RNA . The author is originally from the biologist background, so he introduced some ideas about DNA and RNA. Althought it is not much relevent to the subject, it is nice to know new things. . . Difference between List and Numpy Array . When we defind a variable in list, the true value of each element in the list is the pointer, which point to the location in hardware about where the value is stored. And each element is stored in different place. Making the list take more space and require more time to get accessed. . While in Numpy, the arrays are stored in continuous funciton. So, one array will need only one pointer value to get accessed to all elements in that array. . import numpy as np array_obj = np.arange(12, dtype=np.uint8).reshape((3, 4)) def print_info(a): print(&#39;number of elements:&#39;, a.size) print(&#39;number of dimensions:&#39;, a.ndim) print(&#39;shape:&#39;, a.shape) print(&#39;data type:&#39;, a.dtype) print(&#39;strides:&#39;, a.strides) print(&#39;flags:&#39;) print(a.flags) print_info(array_obj) . . number of elements: 12 number of dimensions: 2 shape: (3, 4) data type: uint8 strides: (4, 1) flags: C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . In about example, each element is of dtype: uint8, so it take 1 bytes. To reach the first element in next row, it would have to skip 4 bytes. so the stride is (4, 1). . &quot;C_CONTIGUOUS&quot; and &quot;F_CONTIGUOUS&quot; states whether the variable is taking value from memory from column contiguous or fortran contiguous. For more explaination, I suggest this answer on stack-overflow. . print(&quot;Transpose array : Strides Changed.&quot;) # Taking Transpose print(array_obj.T) print_info(array_obj.T) print(array_obj.T.ravel(order=&quot;F&quot;)) print_info(array_obj.T.ravel(order=&quot;F&quot;)) print(array_obj.T.ravel(order=&quot;C&quot;)) print_info(array_obj.T.ravel(order=&quot;C&quot;)) . . Transpose array : Strides Changed. [[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] number of elements: 12 number of dimensions: 2 shape: (4, 3) data type: uint8 strides: (1, 4) flags: C_CONTIGUOUS : False F_CONTIGUOUS : True OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False [ 0 1 2 3 4 5 6 7 8 9 10 11] number of elements: 12 number of dimensions: 1 shape: (12,) data type: uint8 strides: (1,) flags: C_CONTIGUOUS : True F_CONTIGUOUS : True OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False [ 0 4 8 1 5 9 2 6 10 3 7 11] number of elements: 12 number of dimensions: 1 shape: (12,) data type: uint8 strides: (1,) flags: C_CONTIGUOUS : True F_CONTIGUOUS : True OWNDATA : True WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . Transposing the array change the behaviour of C_CONTIGUOUS and F_CONTIGUOUS. . Broadcasting . a = np.arange(12, dtype=np.uint8).reshape((4, 3)) b = np.arange(3, dtype=np.uint8) c= np.arange(4, dtype=np.uint8) print(a.shape, b.shape, c.shape) print(a + b) print(a + c) . . (4, 3) (3,) (4,) [[ 0 2 4] [ 3 5 7] [ 6 8 10] [ 9 11 13]] . ValueError Traceback (most recent call last) &lt;ipython-input-9-059306ffba40&gt; in &lt;module&gt; 7 8 print(a + b) -&gt; 9 print(a + c) ValueError: operands could not be broadcast together with shapes (4,3) (4,) . Boradcasting in numpy works when the less dimension is right align with more dimension array. . So, (4, 3) with (3, ) will work, but not with (4, ). (3, ) -&gt; ([4], 3) (4, ) -&gt; ([4], 4) . np.broadcast_arrays, broadcast the array to the desired shape. Notice the strides of dc, is (1, 0), because the row axis&#39; element is broadcasted. . da, dc = np.broadcast_arrays(a, c[:, np.newaxis]) print_info(dc) . . number of elements: 12 number of dimensions: 2 shape: (4, 3) data type: uint8 strides: (1, 0) flags: C_CONTIGUOUS : False F_CONTIGUOUS : False OWNDATA : False WRITEABLE : True (with WARN_ON_WRITE=True) ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . While nb.broadcast_arrys() take one array as reference and broadcast the other array to the same shape as reference one, we can also manipulate the arr to any shape we want withnp.lib.stride_tricks.as_strided(). . def repeat(arr, size): return np.lib.stride_tricks.as_strided( arr, shape=(size, ) + (arr.shape), strides = (0, ) + (arr.strides)) print(repeat(b, 5)) print_info(repeat(b, 5)) . . [[0 1 2] [0 1 2] [0 1 2] [0 1 2] [0 1 2]] number of elements: 15 number of dimensions: 2 shape: (5, 3) data type: uint8 strides: (0, 1) flags: C_CONTIGUOUS : False F_CONTIGUOUS : False OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . This function is often used to find the sliding window of the given array. . def sliding_window(arr, win_size): sliding_win = np.lib.stride_tricks.as_strided( arr, shape = (arr.shape[0]-win_size+1, win_size), strides = (arr.strides[0], arr.strides[0])) return sliding_win a = np.arange(10, dtype=np.uint8) print(sliding_window(a, 3)) print(np.mean(sliding_window(a, 3), axis=1)) . . [[0 1 2] [1 2 3] [2 3 4] [3 4 5] [4 5 6] [5 6 7] [6 7 8] [7 8 9]] [1. 2. 3. 4. 5. 6. 7. 8.] . Let&#39;s do something more exciting. We will find the mean of the sliding window. Resulting in the smoother graph. And we will then find mock moving average. . import matplotlib.pyplot as plt import numpy as np import altair as alt import pandas as pd indexs = np.arange(100) random_arrays = np.random.normal(0, 0.5, size=100) # Add some curve to the graph : Sexy, hehe random_arrays[30:60] += 1 # Let&#39;s smooth it out mean_2 = np.mean(sliding_window(random_arrays, 2), axis=1) padded_mean_2 = np.pad(mean_2, (1, 0)) mean_5 = np.mean(sliding_window(random_arrays, 5), axis=1) padded_mean_5 = np.pad(mean_5, (1, 3)) simple_ema = np.array([0.1, 0.15, 0.2, 0.25, 0.3]) ema_size = simple_ema.size ema = sliding_window(np.pad(random_arrays, (ema_size, ema_size-1), &#39;reflect&#39;), ema_size) * simple_ema ema = np.sum(ema, axis=1)[:-5] df = pd.DataFrame({ &#39;index&#39;:np.hstack((indexs, indexs, indexs, indexs)), &#39;values&#39;:np.hstack([random_arrays, padded_mean_2, padded_mean_5, ema]), &#39;label&#39;:[j for j in [&#39;random_arrays&#39;, &#39;mean with 2 neighbour&#39;, &#39;mean with 5 neighbour&#39;, &#39;mock Exponential Moving Average&#39;] for _ in range(100)] }) # Create a selection that chooses the nearest point &amp; selects based on x-value nearest = alt.selection(type=&#39;single&#39;, nearest=True, on=&#39;mouseover&#39;, fields=[&#39;index&#39;], empty=&#39;none&#39;) # The basic line line = alt.Chart(df).mark_line(interpolate=&#39;basis&#39;).encode( x=&#39;index:Q&#39;, y=&#39;values:Q&#39;, color=&#39;label:N&#39; ) # Transparent selectors across the chart. This is what tells us # the x-value of the cursor selectors = alt.Chart(df).mark_point().encode( x=&#39;index:Q&#39;, opacity=alt.value(0), ).add_selection( nearest ) # Draw points on the line, and highlight based on selection points = line.mark_point().encode( opacity=alt.condition(nearest, alt.value(1), alt.value(0)) ) # Draw text labels near the points, and highlight based on selection text = line.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=alt.condition(nearest, &#39;values:Q&#39;, alt.value(&#39; &#39;)) ) # Draw a rule at the location of the selection rules = alt.Chart(df).mark_rule(color=&#39;gray&#39;).encode( x=&#39;index:Q&#39;, ).transform_filter( nearest ) # Put the five layers into a chart and bind the data alt.layer( line, selectors, points, rules, text ).properties( width=600, height=300 ) # plt.plot(random_arrays, label=&#39;origin&#39;) # plt.plot(mean_2, label=&#39;mean with 2 neighbour&#39;) # plt.plot(mean_5, label=&#39;mean with 5 neighbour&#39;) # plt.plot(ema, label=&#39;mock Exponential Moving Average&#39;) # plt.legend() # plt.show() . . Well, as expected, exponentially moving average have some phase shift. It can be corrected with phase shift as described in adam paper. I am too lazy to implement it. hehe .",
            "url": "https://aungpaing98.github.io/blogs/numpy/notes/2020/01/12/Advanced-Numpy-PyData-Japan-19.html",
            "relUrl": "/numpy/notes/2020/01/12/Advanced-Numpy-PyData-Japan-19.html",
            "date": " • Jan 12, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Study Web from Scratch Notes",
            "content": "Why I started to learn Front-end . It seems like the end of study the machine learning is representing the model, and to the customer, to yourself. I am not saying I am already an expert in Machine Learning, not at all yet. But visualization of deep learning model intrigue me, how is the intermediate(hidden) layer of the model is behaving? Then I have a idea of putting my visualization model online. For that, I will have to know front-end. So my jorney to become front-end start. . How I start my Jornel . The very first thing is advice. I looked for all kinds of advices. Then plan for the whole course, what to study, and what I will focus on. Then, I decided to put main learning time on this website, as this have complete blog posts about every details I need to know as begineer. . So, Let&#39;s get start . Day1 . 2020-1-12-Tuesday . URL . URL stand for Uniform Resoure Locator, Each and every website on the cloud have its own URL, it is like an id. When we make a REQUEST throught the web, it is searching for that URL in the cloud and return us the website from that URL. But, actually, it is not URL that is the actual id of the website, IP is. . IP . IP stands for Internet Protocal, It is the id of the website. . For example, This block . URL IP . https://aungpaing98.github.io/blogs/ | 185.199.108.153 | . HTML . HTML stands for Hyper-Text Markup Language. HTML, with CSS are not programming language, they have no logics, conditions, loops and so on. They focus on the properties, style and layout(position) of the specific text in whole page. . As mentioned in the video, I will need to learn much more about HTML. . Document Sectioning | Document Meta-Data | Block Text Semantics | Inline Text Semantics | Image &amp; Multimedia | Embedded Contents | Scripting | Data Tables | . CSS . CSS stands for Cascading Style Sheet. We can use CSS to basically style each and every elements from HTML. Because there are repeatly used of same tag in a HTML file, using CSS can help to style all the tag which have similar semantic or properties with just one line. . JavaScript . JavaScript was first invented in 1995. Aside from the history, javascript is the real programming that provide the user interactivity and data storage for the webpage. . There are two main javascript that I was introduced. . Server Side (Backend?) | Browser Side (Frontend?) | . Seems like the server side and brower side have huge difference. For now, I guess for the browser side, the browser will have the function of Request for the data, Parsing the documents from the request, Layout and Painting the content. Furthermore, the browser will have to secure the user information from attack. And doing all this with minimum energy and delayed. . For the server side, the server will have to Provide the documents upon request, Store user information if passed. And Backup the information, making sure no data is loss due to breakdown on electricity. . Well, that is all my guess for now. I will get to that later. . SVG . SVG stands for Scalable Vector Grphic. What we saw images in typical format are .jpg or .png format. These are in bitmaps format. where the image is composed of bits, where SVG is composed of equations describing the line in that graphic(image). . The main advantage of SVG over jpg and png is that, it is scalable to any size and will not lose information, cause it is just the equation on the backbone. . For that, I will have to study grapic Software, like Sketch or Adobe Illustrator, which I have no idea about yet. . Day2 . 2020-1-13-Wednesday . Basic CSS . Like HTML, CSS is just a markup language. It is mainly used to style the HTML elements. . Selector . Selector in the CSS indicate the tag that we want to style on. Since there are many types of tags in HTML, there are also many types of Selector in CSS. . Selector css html element . Element Selector/ Tag Selector/ Type Selector | p {} | &lt;p&gt;&lt;/p&gt; | . ID Selector | #my-id {} | &lt;p id=&#39;my-id&#39;&gt;&lt;/p&gt; | . Class Selector | my-class {} | &lt;p class=&#39;myclass&#39;&gt;&lt;/p&gt; | . Attribute Selector | img[src] {} | &lt;img src=&quot;.jpg&quot;&gt; | . Pseudo-Class Selector | a.hover | work when mouse hover the link. | . Difference Types of Elements . Block Element . eg. &lt;body&gt; is a block element which take up space and have mergin and spacing values. . Inline Element . eg. &lt;img&gt; is an inline element, not able to apply margin and spacing. To change it to have block properties, we can use display:block. . Basic Java Script . Java Script is the programming language. So, first let&#39;s start with definding a variable. . Variables . let a = &quot;Hello&quot; var b = &quot;World&quot; . Conditionals . if (condition) { DO THIS }else{ DO THIS } . Function . function name(*args, **kwargs) { } . Default Built-in Methods . alert : warning up when opening the webpage. | prompt : prompt window when opening the webpage. | getAttribute(&#39;color&#39;) : get color attribute of tag | setAttribute(&#39;color&#39;) : set color attribute of tag | document.querySelector(&#39;h1&#39;) : select h1 element | localStorage.setItem() : use localStoage API to store data | localStorage.getItem() : get data from localStoage API. | . Day3 . 2020-1-14-Thursday . What is in the head? . Head of the HTML part play the whole page information, including Title, description, charset, name, author, contents, linking to css and javascript. . Important: A nice website come from a nice head section. For example, the title and description in the web can affect the search result. The charset and lang in html affect the accessability of the website, for those who have difficultly in hearing. . eg. OpenGraphData from Facebook : . &lt;meta properties=&#39;og.image&#39; content=&quot;my profile.png&quot;&gt; . which will share the profile image as the thumbnail through social media for the post. . // defer here mean run HTML first, then run javascript &lt;script src=&quot;&quot; defer&gt;&lt;/script&gt; . // Increase Accessability &lt;html lang=&#39;en-US&#39;&gt; . HTML Text Fundamentals . tags in HTML use &lt;&gt; which give the text structure and meaning, it is also called Semantics. Using the right semantic can very mush improve your webpage quaility, both in search and accessability. . When writing texts in a web, or blog post, first, to be aware is making the hierarchy right. Title (&lt;h1&gt;) then subtilte (h2) and so on. . Also, with use of emphasize in html, it is better to be careful. . &lt;strong&gt; Use to Really Emphasize words. | &lt;em&gt; use to emphasize words. | &lt;b&gt; Make words bold. Not recommanded. | &lt;i&gt; Make words Italic. Not recommanded. | . Advanced Text Formatting . Advanced text formatting including learning more tag semantics. . description list : &lt;dl&gt; | description term : &lt;dl&gt; | description defination : &lt;dd&gt; | block quotes : &lt;blockquote cite=&quot;&quot;&gt; &lt;/blockquote&gt; | inline quotes : &lt;q&gt; &lt;/q&gt; | citation : &lt;cite&gt; &lt;/cite&gt; | Abbreviations : &lt;abbr&gt; | address : &lt;address&gt; &lt;/address&gt; | super and sub script : &lt;sup&gt; &lt;sub&gt; | computer code : &lt;code&gt; &lt;/code&gt; | indentation : &lt;pre&gt; &lt;/pre&gt; (container for code block where indendation is important : python.) | variable name : &lt;var&gt; | keyboard : &lt;kbd&gt; | output : &lt;samp&gt; | timestamp : &lt;time datetime=&quot;2021-1-11&quot;&gt; | . Creating Hyperlink . Simple linking: . &lt;a href = &quot;my.com&quot;&gt;Link to website&lt;/a&gt; &lt;a href = &quot;index.html&quot;&gt;Link to HTML File&lt;/a&gt; &lt;a href = &quot;#id&quot;&gt;Link to ID element&lt;/a&gt; &lt;a href = &quot;mailto:aungpaingcha1@gmail.com&quot;&gt;Mail to Aung Paing&lt;/a&gt; . Day4 . 2020-1-15-Friday . Document and Website Structure . Basic Structures of the webpage include: . header &lt;header&gt; | navigation bar &lt;nav&gt; | main content &lt;main&gt; | sidebar &lt;aside&gt; | footer &lt;footer&gt; | . . Planning a compelet websites . Steps you must go throught for minimum effort for maximum efficiency. . Common Specifications / Nav bar / Footer, etc. | Draw Sketch / Decide contents will be in the page. | brainstorm all other pages. | Card Sorting / Sort all contents into groups. | Sketch the whole rough site map. | Into Coding. | Debugging in HTML . The first thing we should know before going on, is that HTML is not a programming language. And in the browser side, it is not compile, but interpreted. And HTML is permissive code, meaning it will run even if there are some error. The language itself is designed to be that way, because back in the day, if it is not, most developer might find it difficult to work with. And HTML will not be here today. . Like most language, the error in HTML mainly consists of: . Syntax Error | Logic Error | . We can validate our .html file in https://validator.w3.org website. . Technical Terms . HTML (Hyper-Text Markup Language) CSS (Cascading Style Sheet) SVG (Scalable Vector Graphic) URL (Uniform Resource Locator) DOM (Document Object Model) Block Element : eg. &lt;body&gt; is a block element which take up space and have mergin and spacing values, &lt;div&gt; is also and block element. Inline Element : eg. &lt;img&gt; is an inline element, not able to apply margin and spacing. To change it to have block properties, we can use display:block, &lt;span&gt; is also and inline element. .",
            "url": "https://aungpaing98.github.io/blogs/front-end/notes/html/css/javascript/2020/01/10/Web-Study-Notes.html",
            "relUrl": "/front-end/notes/html/css/javascript/2020/01/10/Web-Study-Notes.html",
            "date": " • Jan 10, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "CS231N Study Note",
            "content": "Abstrast . This course conducted by Standford focus on Computer Vision and Deep Learning, and is focus from the basic to the somehow advanced topic. This notebook contain the archives of the note of me taking from the course. If you would like to contribute to the notebook, please leave a comment in the below of the notebook. Link to youtube lecture . Lecture 1 | Introduction to Convolutional Neural Networks for Visual Recognition . Brief introduction to the history of Computer Vision, Deep Learning and the problems to tackle in Computer Vision. Link to my Note . Lecture 2 | Image Classification Pipelines . Introduction to the image classification pipelines and train a simple model for image classification. Link to my Note . Lecture 3 | Loss Function and Optimization . Introduction to hinge loss, softmax function and optimization. Link to my Note . Lecture 4 | Backpropagation and Neural Network . Introduction to Neural Network backpropagation flow, equations and intuiation. Link to my Note . Lecture 5 | Convolutional Neural Network . History and modern about CNN and its basic operations. Link to my Note . Lecture 6 | Training Neural Network 1 . Basic Training Procedure hyperparameters optimization. Link to my Note . Lecture 7 | Training Neural Network 2 . Basic Training Procedure hyperparameters optimization. Link to my Note .",
            "url": "https://aungpaing98.github.io/blogs/cs231n/computer-vision/deep-learning/notes/2020/01/10/Standford-CS231N-Notes.html",
            "relUrl": "/cs231n/computer-vision/deep-learning/notes/2020/01/10/Standford-CS231N-Notes.html",
            "date": " • Jan 10, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "&lt;h1&gt;Welcome to Paing&#39;s Blog&lt;/h1&gt; &lt;/div&gt; &lt;div class=&#39;text-wrapper&#39;&gt; &lt;h2&gt;Interests&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Computer Vision&lt;/li&gt; &lt;li&gt;Machine Learning&lt;/li&gt; &lt;li&gt;Deep Learning&lt;/li&gt; &lt;li&gt;Data Science&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Recent Activities&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Junior Machine Learning Engineer at Omdena Global Challenge&lt;/li&gt; &lt;/ul&gt; &lt;!-- &lt;h2&gt;Skill&lt;/h2&gt; &lt;div class=&quot;skill-wrapper&quot;&gt; &lt;img src=&quot;https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/python/python.png&quot; width=&quot;40px&quot; style=&quot;vertical-align:middle;margin:0px 20px&quot;&gt; &lt;img src=&quot;https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/markdown/markdown.png&quot; width=&quot;35px&quot; style=&quot;vertical-align:middle;margin:0px 20px&quot;&gt; &lt;img src=&quot;https://keras.io/img/logo.png&quot; width=&quot;100px&quot; style=&quot;vertical-align:middle;margin:0px 20px&quot;&gt; &lt;img src=&quot;https://github.com/pytorch/pytorch/raw/master/docs/source/_static/img/pytorch-logo-dark.png&quot; width=&quot;100px&quot; style=&quot;vertical-align:middle;margin:0px 20px&quot;&gt; &lt;img src=&quot;https://github.com/fastai/fastai/blob/master/docs_src/images/company_logo.png?raw=true&quot; width=&quot;35px&quot; style=&quot;vertical-align:middle;margin:0px 20px&quot;&gt; &lt;/div&gt; --&gt; &lt;h2&gt;Publishcations&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://ieeexplore.ieee.org/abstract/document/9294048/&quot;&gt;Coverage Path Planning for Decomposition Reconfigurable Grid-Maps Using Deep Reinforcement Learning Based Travelling Salesman Problem,&quot; in IEEE Access, vol. 8, pp. 225945-225956, 2020, doi: 10.1109/ACCESS.2020.3045027&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Experiences&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Machine learning Internship at &lt;a href=&quot;https://www.acromyanmar.com&quot;&gt;Acroquest Myanmar Technology&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Member as Deep Learning engineer in project : &lt;a href=&quot;https://fb.watch/2Q7ELU4hwG/&quot;&gt;AI Face Recognition and Automatic Non-contact Temperature Measurement Device&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Teaching Assistant at Computer Vision and Machine Learning course &lt;a href=&quot;https://ytu-cvlab.github.io/mce-51069/&quot;&gt;McE-51069&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Speaker in YTU IoT Talk Shwe Ohh with Topic &quot;Blogging with FastPage&quot;&lt;/li&gt; &lt;li&gt;Junior Machine Learning Engineer at Omdena Global Challenge&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; .",
          "url": "https://aungpaing98.github.io/blogs/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://aungpaing98.github.io/blogs/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}